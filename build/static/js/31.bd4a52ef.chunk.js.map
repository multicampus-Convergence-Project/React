{"version":3,"sources":["../node_modules/@aws-amplify/ui-components/dist/esm-es5/amplify-radio-button_2.entry.js"],"names":["__webpack_require__","r","__webpack_exports__","d","AmplifyRadioButton","AmplifyTOTPSetup","_index_39969785_js__WEBPACK_IMPORTED_MODULE_0__","_aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__","_aws_amplify_core__WEBPACK_IMPORTED_MODULE_2__","_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_3__","_aws_amplify_auth__WEBPACK_IMPORTED_MODULE_4__","_Translations_392acb9b_js__WEBPACK_IMPORTED_MODULE_5__","_constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_6__","_helpers_01ecf5f9_js__WEBPACK_IMPORTED_MODULE_7__","_auth_helpers_2fada98e_js__WEBPACK_IMPORTED_MODULE_8__","buffer__WEBPACK_IMPORTED_MODULE_9__","buffer__WEBPACK_IMPORTED_MODULE_9___default","n","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","v","op","TypeError","call","pop","length","push","hostRef","Object","placeholder","checked","disabled","prototype","render","class","assign","type","name","onInput","handleInputChange","id","fieldId","inputProps","htmlFor","style","canPromise","toString","isarray","Array","isArray","arr","Buffer","TYPED_ARRAY_SUPPORT","Uint8Array","__proto__","foo","typedArraySupport","K_MAX_LENGTH","arg","offset","allocUnsafe","that","ArrayBuffer","array","byteOffset","byteLength","RangeError","buf","undefined","fromArrayLike","fromArrayBuffer","string","createBuffer","actual","write","slice","fromString","obj","isBuffer","len","copy","buffer","val","data","fromObject","from","size","i","utf8ToBytes","units","codePoint","Infinity","leadSurrogate","bytes","charCodeAt","Error","isView","species","defineProperty","configurable","enumerable","writable","isFinite","remaining","src","dst","blitBuffer","utf8Write","start","end","newBuf","subarray","sliceLen","target","targetStart","set","fill","code","concat","list","pos","_isBuffer","b","toSJISFunction","typedarrayBuffer","alloc","CODEWORDS_COUNT","utils","getSymbolSize","version","getSymbolTotalCodewords","getBCHDigit","digit","setToSJISFunction","isKanjiModeEnabled","toSJIS","kanji","createCommonjsModule","fn","basedir","module","path","exports","require","base","commonjsRequire","errorCorrectionLevel","L","bit","M","Q","H","isValid","level","defaultValue","toLowerCase","BitBuffer","get","index","bufIndex","Math","floor","put","num","putBit","getLengthInBits","bitBuffer","BitMatrix","reservedBit","row","col","reserved","xor","isReserved","bitMatrix","alignmentPattern","getRowColCoords","posCount","intervals","ceil","positions","reverse","getPositions","coords","posLength","j","getSymbolSize$1","finderPattern","maskPattern","Patterns","PATTERN000","PATTERN001","PATTERN010","PATTERN011","PATTERN100","PATTERN101","PATTERN110","PATTERN111","PenaltyScores","getMaskAt","mask","isNaN","parseInt","getPenaltyN1","points","sameCountCol","sameCountRow","lastCol","lastRow","getPenaltyN2","last","getPenaltyN3","bitsCol","bitsRow","getPenaltyN4","darkCount","modulesCount","abs","applyMask","pattern","getBestMask","setupFormatFunc","numPatterns","keys","bestPattern","lowerPenalty","p","penalty","EC_BLOCKS_TABLE","EC_CODEWORDS_TABLE","errorCorrectionCode","getBlocksCount","errorCorrectionLevel$1","getTotalCodewordsCount","EXP_TABLE","LOG_TABLE","x","galoisField","polynomial","mul","p1","p2","coeff","mod","divident","divisor","generateECPolynomial","degree","poly","Buffer$1","a","ReedSolomonEncoder","genPoly","initialize","encode","pad","paddedData","remainder","buff","reedSolomonEncoder","versionCheck","byte","replace","KANJI","RegExp","BYTE_KANJI","BYTE","NUMERIC","ALPHANUMERIC","TEST_KANJI","TEST_NUMERIC","TEST_ALPHANUMERIC","regex","testKanji","str","test","testNumeric","testAlphanumeric","mode","ccBits","MIXED","getCharCountIndicator","getBestModeForData","dataStr","G18_BCH","getReservedBitsCount","mode$1","getTotalBitsFromDataArray","segments","totalBits","forEach","reservedBits","getBitsLength","getCapacity","dataTotalCodewordsBits","usableBits","getBestVersionForData","seg","ecl","currentVersion","getBestVersionForMixedData","getBestVersionForDataLength","getLength","getEncodedBits","G15_BCH","formatInfo","NumericData","group","substr","remainingNum","numericData","ALPHA_NUM_CHARS","AlphanumericData","indexOf","alphanumericData","ByteData","l","byteData","KanjiData","kanjiData","dijkstra_1","dijkstra","single_source_shortest_paths","graph","s","predecessors","costs","closest","u","cost_of_s_to_u","adjacent_nodes","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","open","PriorityQueue","make","empty","cost","hasOwnProperty","msg","join","extract_shortest_path_from_predecessor_list","nodes","find_path","opts","key","T","queue","sorter","default_sorter","item","sort","shift","getStringByteLength","unescape","encodeURIComponent","getSegments","exec","getSegmentsFromString","byteSegs","kanjiSegs","numSegs","alphaNumSegs","s1","s2","map","getSegmentBitsLength","buildSingleSegment","modesHint","bestMode","fromArray","reduce","acc","table","prevNodeIds","nodeGroup","currentNodeIds","node","lastCount","prevNodeId","buildGraph","segs","buildNodes","optimizedSegs","curr","prevSeg","mergeSegments","rawSplit","setupFormatInfo","matrix","bits","createData","remainingByte","totalCodewords","ecTotalCodewords","dataTotalCodewords","ecTotalBlocks","blocksInGroup1","totalCodewordsInGroup1","dataCodewordsInGroup1","dataCodewordsInGroup2","ecCount","rs","dcData","ecData","maxDataSize","dataSize","max","createCodewords","createSymbol","version$1","maskPattern$1","segments$1","estimatedVersion","rawSegments","bestVersion","dataBits","moduleCount","modules","c","setupFinderPattern","setupTimingPattern","setupAlignmentPattern","setupVersionInfo","inc","bitIndex","byteIndex","dark","setupData","bind","qrcode","create","options","toSJISFunc","utils$1","hex2rgba","hex","hexCode","split","hexValue","getOptions","color","margin","width","scale","light","rendererOpts","getScale","qrSize","getImageWidth","qrToImageData","imgData","qr","symbolSize","scaledMargin","palette","posDst","pxColor","canvas","qrData","canvasEl","getContext","document","createElement","getCanvasElement","ctx","image","createImageData","clearRect","height","clearCanvas","putImageData","renderToDataURL","toDataURL","quality","getColorAttrib","attrib","alpha","toFixed","svgCmd","cmd","svgTag","cb","qrcodesize","bg","moveBy","newRow","lineLength","qrToPath","viewBox","renderCanvas","renderFunc","text","args","arguments","argsNum","isLastArgCb","browser","toCanvas","logger","class_1","autoFocus","handleAuthStateChange","headerText","TOTP_HEADER_TEXT","issuer","TOTP_ISSUER","setupMessage","qrCodeInput","loading","componentWillLoad","setup","buildOtpAuthPath","user","secretKey","username","onTOTPEvent","event","_a","debug","handleTotpInputChange","generateQRCode","codeFromTotp","error_1","_b","qrCodeImageSource","encodedIssuer","error_2","encodeURI","setupTOTP","TOTP_SETUP_FAILURE","verifyTotpToken","error_3","preventDefault","setPreferredMFA","TOTP","TOTP_SUCCESS_MESSAGE","error","_this","submitButtonText","TOTP_SUBMIT_BUTTON_TEXT","handleSubmit","alt","QR_CODE_ALT","TOTP_LABEL"],"mappings":"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","file":"static/js/31.bd4a52ef.chunk.js","sourcesContent":["var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { r as registerInstance, h, H as Host } from './index-39969785.js';\nimport { Logger, I18n } from '@aws-amplify/core';\nimport { M as MfaOption } from './auth-types-78df304e.js';\nimport { Auth } from '@aws-amplify/auth';\nimport { T as Translations } from './Translations-392acb9b.js';\nimport { S as SETUP_TOTP, i as SUCCESS, N as NO_AUTH_MODULE_FOUND } from './constants-d1abe7de.js';\nimport { d as dispatchAuthStateChangeEvent, a as dispatchToastHubEvent } from './helpers-01ecf5f9.js';\nimport { c as checkContact } from './auth-helpers-2fada98e.js';\nimport buffer from 'buffer';\nvar amplifyRadioButtonCss = \":host{--font-family:var(--amplify-font-family)}.radio-button{display:block;width:100%;padding:16px;font-size:var(--amplify-text-sm);font-family:var(--font-family)}.radio-button input{margin-right:12px}\";\n\nvar AmplifyRadioButton =\n/** @class */\nfunction () {\n  function AmplifyRadioButton(hostRef) {\n    registerInstance(this, hostRef);\n    /** (Optional) The placeholder for the input element.  Using hints is recommended, but placeholders can also be useful to convey information to users. */\n\n    this.placeholder = '';\n    /** If `true`, the radio button is selected. */\n\n    this.checked = false;\n    /** If `true`, the checkbox is disabled */\n\n    this.disabled = false;\n  }\n\n  AmplifyRadioButton.prototype.render = function () {\n    return h(\"span\", {\n      class: \"radio-button\"\n    }, h(\"input\", Object.assign({\n      type: \"radio\",\n      name: this.name,\n      value: this.value,\n      onInput: this.handleInputChange,\n      placeholder: this.placeholder,\n      id: this.fieldId,\n      checked: this.checked,\n      disabled: this.disabled\n    }, this.inputProps)), h(\"amplify-label\", {\n      htmlFor: this.fieldId\n    }, this.label));\n  };\n\n  return AmplifyRadioButton;\n}();\n\nAmplifyRadioButton.style = amplifyRadioButtonCss; // can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\n\nvar canPromise = function canPromise() {\n  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;\n};\n\nvar toString = {}.toString;\n\nvar isarray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\nfunction typedArraySupport() {\n  // Can typed array instances be augmented?\n  try {\n    var arr = new Uint8Array(1);\n    arr.__proto__ = {\n      __proto__: Uint8Array.prototype,\n      foo: function foo() {\n        return 42;\n      }\n    };\n    return arr.foo() === 42;\n  } catch (e) {\n    return false;\n  }\n}\n\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\nvar K_MAX_LENGTH = Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n\nfunction Buffer(arg, offset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, offset, length);\n  }\n\n  if (typeof arg === 'number') {\n    return allocUnsafe(this, arg);\n  }\n\n  return from(this, arg, offset, length);\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array; // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\n  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true,\n      enumerable: false,\n      writable: false\n    });\n  }\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n  }\n\n  return length | 0;\n}\n\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n}\n\nfunction createBuffer(that, length) {\n  var buf;\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    buf = new Uint8Array(length);\n    buf.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    buf = that;\n\n    if (buf === null) {\n      buf = new Buffer(length);\n    }\n\n    buf.length = length;\n  }\n\n  return buf;\n}\n\nfunction allocUnsafe(that, size) {\n  var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      buf[i] = 0;\n    }\n  }\n\n  return buf;\n}\n\nfunction fromString(that, string) {\n  var length = byteLength(string) | 0;\n  var buf = createBuffer(that, length);\n  var actual = buf.write(string);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n  }\n\n  return buf;\n}\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  var buf = createBuffer(that, length);\n\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255;\n  }\n\n  return buf;\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n\n  var buf;\n\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array);\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset);\n  } else {\n    buf = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    buf.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    buf = fromArrayLike(that, buf);\n  }\n\n  return buf;\n}\n\nfunction fromObject(that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    var buf = createBuffer(that, len);\n\n    if (buf.length === 0) {\n      return buf;\n    }\n\n    obj.copy(buf, 0, 0, len);\n    return buf;\n  }\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n\n      return fromArrayLike(that, obj);\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i); // is surrogate component\n\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } // valid lead\n\n\n        leadSurrogate = codePoint;\n        continue;\n      } // 2 leads in a row\n\n\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      } // valid surrogate pair\n\n\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null; // encode utf8\n\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction byteLength(string) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0;\n  return utf8ToBytes(string).length;\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction from(that, value, offset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, offset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value);\n  }\n\n  return fromObject(that, value);\n}\n\nBuffer.prototype.write = function write(string, offset, length) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    length = this.length;\n    offset = 0; // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    length = this.length;\n    offset = 0; // Buffer#write(string, offset[, length])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n\n    if (isFinite(length)) {\n      length = length | 0;\n    } else {\n      length = undefined;\n    }\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  return utf8Write(this, string, offset, length);\n};\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n  var newBuf;\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf;\n};\n\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n  if (end > this.length) end = this.length;\n\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n\n  return len;\n};\n\nBuffer.prototype.fill = function fill(val, start, end) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      end = this.length;\n    }\n\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n\n      if (code < 256) {\n        val = code;\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  } // Invalid ranges are not set to a default, so can range check early.\n\n\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n  if (!val) val = 0;\n  var i;\n\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : new Buffer(val);\n    var len = bytes.length;\n\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!isarray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return createBuffer(null, 0);\n  }\n\n  var i;\n\n  if (length === undefined) {\n    length = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = allocUnsafe(null, length);\n  var pos = 0;\n\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n\n  return buffer;\n};\n\nBuffer.byteLength = byteLength;\nBuffer.prototype._isBuffer = true;\n\nBuffer.isBuffer = function isBuffer(b) {\n  return !!(b != null && b._isBuffer);\n};\n\nvar alloc = function alloc(size) {\n  var buffer = new Buffer(size);\n  buffer.fill(0);\n  return buffer;\n};\n\nvar from_1 = function from_1(data) {\n  return new Buffer(data);\n};\n\nvar typedarrayBuffer = {\n  alloc: alloc,\n  from: from_1\n};\nvar toSJISFunction;\nvar CODEWORDS_COUNT = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\n\nvar getSymbolSize = function getSymbolSize(version) {\n  if (!version) throw new Error('\"version\" cannot be null or undefined');\n  if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40');\n  return version * 4 + 17;\n};\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\n\n\nvar getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {\n  return CODEWORDS_COUNT[version];\n};\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\n\n\nvar getBCHDigit = function getBCHDigit(data) {\n  var digit = 0;\n\n  while (data !== 0) {\n    digit++;\n    data >>>= 1;\n  }\n\n  return digit;\n};\n\nvar setToSJISFunction = function setToSJISFunction(f) {\n  if (typeof f !== 'function') {\n    throw new Error('\"toSJISFunc\" is not a valid function.');\n  }\n\n  toSJISFunction = f;\n};\n\nvar isKanjiModeEnabled = function isKanjiModeEnabled() {\n  return typeof toSJISFunction !== 'undefined';\n};\n\nvar toSJIS = function toSJIS(kanji) {\n  return toSJISFunction(kanji);\n};\n\nvar utils = {\n  getSymbolSize: getSymbolSize,\n  getSymbolTotalCodewords: getSymbolTotalCodewords,\n  getBCHDigit: getBCHDigit,\n  setToSJISFunction: setToSJISFunction,\n  isKanjiModeEnabled: isKanjiModeEnabled,\n  toSJIS: toSJIS\n};\n\nfunction createCommonjsModule(fn, basedir, module) {\n  return module = {\n    path: basedir,\n    exports: {},\n    require: function require(path, base) {\n      return commonjsRequire();\n    }\n  }, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire() {\n  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar errorCorrectionLevel = createCommonjsModule(function (module, exports) {\n  exports.L = {\n    bit: 1\n  };\n  exports.M = {\n    bit: 0\n  };\n  exports.Q = {\n    bit: 3\n  };\n  exports.H = {\n    bit: 2\n  };\n\n  function fromString(string) {\n    if (typeof string !== 'string') {\n      throw new Error('Param is not a string');\n    }\n\n    var lcStr = string.toLowerCase();\n\n    switch (lcStr) {\n      case 'l':\n      case 'low':\n        return exports.L;\n\n      case 'm':\n      case 'medium':\n        return exports.M;\n\n      case 'q':\n      case 'quartile':\n        return exports.Q;\n\n      case 'h':\n      case 'high':\n        return exports.H;\n\n      default:\n        throw new Error('Unknown EC Level: ' + string);\n    }\n  }\n\n  exports.isValid = function isValid(level) {\n    return level && typeof level.bit !== 'undefined' && level.bit >= 0 && level.bit < 4;\n  };\n\n  exports.from = function from(value, defaultValue) {\n    if (exports.isValid(value)) {\n      return value;\n    }\n\n    try {\n      return fromString(value);\n    } catch (e) {\n      return defaultValue;\n    }\n  };\n});\n\nfunction BitBuffer() {\n  this.buffer = [];\n  this.length = 0;\n}\n\nBitBuffer.prototype = {\n  get: function get(index) {\n    var bufIndex = Math.floor(index / 8);\n    return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;\n  },\n  put: function put(num, length) {\n    for (var i = 0; i < length; i++) {\n      this.putBit((num >>> length - i - 1 & 1) === 1);\n    }\n  },\n  getLengthInBits: function getLengthInBits() {\n    return this.length;\n  },\n  putBit: function putBit(bit) {\n    var bufIndex = Math.floor(this.length / 8);\n\n    if (this.buffer.length <= bufIndex) {\n      this.buffer.push(0);\n    }\n\n    if (bit) {\n      this.buffer[bufIndex] |= 0x80 >>> this.length % 8;\n    }\n\n    this.length++;\n  }\n};\nvar bitBuffer = BitBuffer;\n/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\n\nfunction BitMatrix(size) {\n  if (!size || size < 1) {\n    throw new Error('BitMatrix size must be defined and greater than 0');\n  }\n\n  this.size = size;\n  this.data = typedarrayBuffer.alloc(size * size);\n  this.reservedBit = typedarrayBuffer.alloc(size * size);\n}\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\n\n\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n  var index = row * this.size + col;\n  this.data[index] = value;\n  if (reserved) this.reservedBit[index] = true;\n};\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\n\n\nBitMatrix.prototype.get = function (row, col) {\n  return this.data[row * this.size + col];\n};\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\n\n\nBitMatrix.prototype.xor = function (row, col, value) {\n  this.data[row * this.size + col] ^= value;\n};\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\n\n\nBitMatrix.prototype.isReserved = function (row, col) {\n  return this.reservedBit[row * this.size + col];\n};\n\nvar bitMatrix = BitMatrix;\nvar alignmentPattern = createCommonjsModule(function (module, exports) {\n  /**\n   * Alignment pattern are fixed reference pattern in defined positions\n   * in a matrix symbology, which enables the decode software to re-synchronise\n   * the coordinate mapping of the image modules in the event of moderate amounts\n   * of distortion of the image.\n   *\n   * Alignment patterns are present only in QR Code symbols of version 2 or larger\n   * and their number depends on the symbol version.\n   */\n  var getSymbolSize = utils.getSymbolSize;\n  /**\n   * Calculate the row/column coordinates of the center module of each alignment pattern\n   * for the specified QR Code version.\n   *\n   * The alignment patterns are positioned symmetrically on either side of the diagonal\n   * running from the top left corner of the symbol to the bottom right corner.\n   *\n   * Since positions are simmetrical only half of the coordinates are returned.\n   * Each item of the array will represent in turn the x and y coordinate.\n   * @see {@link getPositions}\n   *\n   * @param  {Number} version QR Code version\n   * @return {Array}          Array of coordinate\n   */\n\n  exports.getRowColCoords = function getRowColCoords(version) {\n    if (version === 1) return [];\n    var posCount = Math.floor(version / 7) + 2;\n    var size = getSymbolSize(version);\n    var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;\n    var positions = [size - 7]; // Last coord is always (size - 7)\n\n    for (var i = 1; i < posCount - 1; i++) {\n      positions[i] = positions[i - 1] - intervals;\n    }\n\n    positions.push(6); // First coord is always 6\n\n    return positions.reverse();\n  };\n  /**\n   * Returns an array containing the positions of each alignment pattern.\n   * Each array's element represent the center point of the pattern as (x, y) coordinates\n   *\n   * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n   * and filtering out the items that overlaps with finder pattern\n   *\n   * @example\n   * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n   * The alignment patterns, therefore, are to be centered on (row, column)\n   * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n   * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n   * and are not therefore used for alignment patterns.\n   *\n   * var pos = getPositions(7)\n   * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n   *\n   * @param  {Number} version QR Code version\n   * @return {Array}          Array of coordinates\n   */\n\n\n  exports.getPositions = function getPositions(version) {\n    var coords = [];\n    var pos = exports.getRowColCoords(version);\n    var posLength = pos.length;\n\n    for (var i = 0; i < posLength; i++) {\n      for (var j = 0; j < posLength; j++) {\n        // Skip if position is occupied by finder patterns\n        if (i === 0 && j === 0 || // top-left\n        i === 0 && j === posLength - 1 || // bottom-left\n        i === posLength - 1 && j === 0) {\n          // top-right\n          continue;\n        }\n\n        coords.push([pos[i], pos[j]]);\n      }\n    }\n\n    return coords;\n  };\n});\nvar getSymbolSize$1 = utils.getSymbolSize;\nvar FINDER_PATTERN_SIZE = 7;\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\n\nvar getPositions = function getPositions(version) {\n  var size = getSymbolSize$1(version);\n  return [// top-left\n  [0, 0], // top-right\n  [size - FINDER_PATTERN_SIZE, 0], // bottom-left\n  [0, size - FINDER_PATTERN_SIZE]];\n};\n\nvar finderPattern = {\n  getPositions: getPositions\n};\nvar maskPattern = createCommonjsModule(function (module, exports) {\n  /**\n   * Data mask pattern reference\n   * @type {Object}\n   */\n  exports.Patterns = {\n    PATTERN000: 0,\n    PATTERN001: 1,\n    PATTERN010: 2,\n    PATTERN011: 3,\n    PATTERN100: 4,\n    PATTERN101: 5,\n    PATTERN110: 6,\n    PATTERN111: 7\n  };\n  /**\n   * Weighted penalty scores for the undesirable features\n   * @type {Object}\n   */\n\n  var PenaltyScores = {\n    N1: 3,\n    N2: 3,\n    N3: 40,\n    N4: 10\n  };\n  /**\n   * Check if mask pattern value is valid\n   *\n   * @param  {Number}  mask    Mask pattern\n   * @return {Boolean}         true if valid, false otherwise\n   */\n\n  exports.isValid = function isValid(mask) {\n    return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;\n  };\n  /**\n   * Returns mask pattern from a value.\n   * If value is not valid, returns undefined\n   *\n   * @param  {Number|String} value        Mask pattern value\n   * @return {Number}                     Valid mask pattern or undefined\n   */\n\n\n  exports.from = function from(value) {\n    return exports.isValid(value) ? parseInt(value, 10) : undefined;\n  };\n  /**\n  * Find adjacent modules in row/column with the same color\n  * and assign a penalty value.\n  *\n  * Points: N1 + i\n  * i is the amount by which the number of adjacent modules of the same color exceeds 5\n  */\n\n\n  exports.getPenaltyN1 = function getPenaltyN1(data) {\n    var size = data.size;\n    var points = 0;\n    var sameCountCol = 0;\n    var sameCountRow = 0;\n    var lastCol = null;\n    var lastRow = null;\n\n    for (var row = 0; row < size; row++) {\n      sameCountCol = sameCountRow = 0;\n      lastCol = lastRow = null;\n\n      for (var col = 0; col < size; col++) {\n        var module = data.get(row, col);\n\n        if (module === lastCol) {\n          sameCountCol++;\n        } else {\n          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n          lastCol = module;\n          sameCountCol = 1;\n        }\n\n        module = data.get(col, row);\n\n        if (module === lastRow) {\n          sameCountRow++;\n        } else {\n          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n          lastRow = module;\n          sameCountRow = 1;\n        }\n      }\n\n      if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n      if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n    }\n\n    return points;\n  };\n  /**\n   * Find 2x2 blocks with the same color and assign a penalty value\n   *\n   * Points: N2 * (m - 1) * (n - 1)\n   */\n\n\n  exports.getPenaltyN2 = function getPenaltyN2(data) {\n    var size = data.size;\n    var points = 0;\n\n    for (var row = 0; row < size - 1; row++) {\n      for (var col = 0; col < size - 1; col++) {\n        var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);\n        if (last === 4 || last === 0) points++;\n      }\n    }\n\n    return points * PenaltyScores.N2;\n  };\n  /**\n   * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n   * preceded or followed by light area 4 modules wide\n   *\n   * Points: N3 * number of pattern found\n   */\n\n\n  exports.getPenaltyN3 = function getPenaltyN3(data) {\n    var size = data.size;\n    var points = 0;\n    var bitsCol = 0;\n    var bitsRow = 0;\n\n    for (var row = 0; row < size; row++) {\n      bitsCol = bitsRow = 0;\n\n      for (var col = 0; col < size; col++) {\n        bitsCol = bitsCol << 1 & 0x7FF | data.get(row, col);\n        if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;\n        bitsRow = bitsRow << 1 & 0x7FF | data.get(col, row);\n        if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;\n      }\n    }\n\n    return points * PenaltyScores.N3;\n  };\n  /**\n   * Calculate proportion of dark modules in entire symbol\n   *\n   * Points: N4 * k\n   *\n   * k is the rating of the deviation of the proportion of dark modules\n   * in the symbol from 50% in steps of 5%\n   */\n\n\n  exports.getPenaltyN4 = function getPenaltyN4(data) {\n    var darkCount = 0;\n    var modulesCount = data.data.length;\n\n    for (var i = 0; i < modulesCount; i++) {\n      darkCount += data.data[i];\n    }\n\n    var k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);\n    return k * PenaltyScores.N4;\n  };\n  /**\n   * Return mask value at given position\n   *\n   * @param  {Number} maskPattern Pattern reference value\n   * @param  {Number} i           Row\n   * @param  {Number} j           Column\n   * @return {Boolean}            Mask value\n   */\n\n\n  function getMaskAt(maskPattern, i, j) {\n    switch (maskPattern) {\n      case exports.Patterns.PATTERN000:\n        return (i + j) % 2 === 0;\n\n      case exports.Patterns.PATTERN001:\n        return i % 2 === 0;\n\n      case exports.Patterns.PATTERN010:\n        return j % 3 === 0;\n\n      case exports.Patterns.PATTERN011:\n        return (i + j) % 3 === 0;\n\n      case exports.Patterns.PATTERN100:\n        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n\n      case exports.Patterns.PATTERN101:\n        return i * j % 2 + i * j % 3 === 0;\n\n      case exports.Patterns.PATTERN110:\n        return (i * j % 2 + i * j % 3) % 2 === 0;\n\n      case exports.Patterns.PATTERN111:\n        return (i * j % 3 + (i + j) % 2) % 2 === 0;\n\n      default:\n        throw new Error('bad maskPattern:' + maskPattern);\n    }\n  }\n  /**\n   * Apply a mask pattern to a BitMatrix\n   *\n   * @param  {Number}    pattern Pattern reference number\n   * @param  {BitMatrix} data    BitMatrix data\n   */\n\n\n  exports.applyMask = function applyMask(pattern, data) {\n    var size = data.size;\n\n    for (var col = 0; col < size; col++) {\n      for (var row = 0; row < size; row++) {\n        if (data.isReserved(row, col)) continue;\n        data.xor(row, col, getMaskAt(pattern, row, col));\n      }\n    }\n  };\n  /**\n   * Returns the best mask pattern for data\n   *\n   * @param  {BitMatrix} data\n   * @return {Number} Mask pattern reference number\n   */\n\n\n  exports.getBestMask = function getBestMask(data, setupFormatFunc) {\n    var numPatterns = Object.keys(exports.Patterns).length;\n    var bestPattern = 0;\n    var lowerPenalty = Infinity;\n\n    for (var p = 0; p < numPatterns; p++) {\n      setupFormatFunc(p);\n      exports.applyMask(p, data); // Calculate penalty\n\n      var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data); // Undo previously applied mask\n\n      exports.applyMask(p, data);\n\n      if (penalty < lowerPenalty) {\n        lowerPenalty = penalty;\n        bestPattern = p;\n      }\n    }\n\n    return bestPattern;\n  };\n});\nvar EC_BLOCKS_TABLE = [// L  M  Q  H\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81];\nvar EC_CODEWORDS_TABLE = [// L  M  Q  H\n7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];\n/**\n * Returns the number of error correction block that the QR Code should contain\n * for the specified version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction blocks\n */\n\nvar getBlocksCount = function getBlocksCount(version, errorCorrectionLevel$1) {\n  switch (errorCorrectionLevel$1) {\n    case errorCorrectionLevel.L:\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];\n\n    case errorCorrectionLevel.M:\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];\n\n    case errorCorrectionLevel.Q:\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];\n\n    case errorCorrectionLevel.H:\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];\n\n    default:\n      return undefined;\n  }\n};\n/**\n * Returns the number of error correction codewords to use for the specified\n * version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction codewords\n */\n\n\nvar getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel$1) {\n  switch (errorCorrectionLevel$1) {\n    case errorCorrectionLevel.L:\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];\n\n    case errorCorrectionLevel.M:\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];\n\n    case errorCorrectionLevel.Q:\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];\n\n    case errorCorrectionLevel.H:\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];\n\n    default:\n      return undefined;\n  }\n};\n\nvar errorCorrectionCode = {\n  getBlocksCount: getBlocksCount,\n  getTotalCodewordsCount: getTotalCodewordsCount\n};\nvar EXP_TABLE = typedarrayBuffer.alloc(512);\nvar LOG_TABLE = typedarrayBuffer.alloc(256);\n\n(function initTables() {\n  var x = 1;\n\n  for (var i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x;\n    LOG_TABLE[x] = i;\n    x <<= 1; // multiply by 2\n    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n    // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n\n    if (x & 0x100) {\n      // similar to x >= 256, but a lot faster (because 0x100 == 256)\n      x ^= 0x11D;\n    }\n  } // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n  // stay inside the bounds (because we will mainly use this table for the multiplication of\n  // two GF numbers, no more).\n  // @see {@link mul}\n\n\n  for (i = 255; i < 512; i++) {\n    EXP_TABLE[i] = EXP_TABLE[i - 255];\n  }\n})();\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\n\n\nvar log = function log(n) {\n  if (n < 1) throw new Error('log(' + n + ')');\n  return LOG_TABLE[n];\n};\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\n\n\nvar exp = function exp(n) {\n  return EXP_TABLE[n];\n};\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\n\n\nvar mul = function mul(x, y) {\n  if (x === 0 || y === 0) return 0; // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n  // @see {@link initTables}\n\n  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];\n};\n\nvar galoisField = {\n  log: log,\n  exp: exp,\n  mul: mul\n};\nvar polynomial = createCommonjsModule(function (module, exports) {\n  /**\n   * Multiplies two polynomials inside Galois Field\n   *\n   * @param  {Buffer} p1 Polynomial\n   * @param  {Buffer} p2 Polynomial\n   * @return {Buffer}    Product of p1 and p2\n   */\n  exports.mul = function mul(p1, p2) {\n    var coeff = typedarrayBuffer.alloc(p1.length + p2.length - 1);\n\n    for (var i = 0; i < p1.length; i++) {\n      for (var j = 0; j < p2.length; j++) {\n        coeff[i + j] ^= galoisField.mul(p1[i], p2[j]);\n      }\n    }\n\n    return coeff;\n  };\n  /**\n   * Calculate the remainder of polynomials division\n   *\n   * @param  {Buffer} divident Polynomial\n   * @param  {Buffer} divisor  Polynomial\n   * @return {Buffer}          Remainder\n   */\n\n\n  exports.mod = function mod(divident, divisor) {\n    var result = typedarrayBuffer.from(divident);\n\n    while (result.length - divisor.length >= 0) {\n      var coeff = result[0];\n\n      for (var i = 0; i < divisor.length; i++) {\n        result[i] ^= galoisField.mul(divisor[i], coeff);\n      } // remove all zeros from buffer head\n\n\n      var offset = 0;\n\n      while (offset < result.length && result[offset] === 0) {\n        offset++;\n      }\n\n      result = result.slice(offset);\n    }\n\n    return result;\n  };\n  /**\n   * Generate an irreducible generator polynomial of specified degree\n   * (used by Reed-Solomon encoder)\n   *\n   * @param  {Number} degree Degree of the generator polynomial\n   * @return {Buffer}        Buffer containing polynomial coefficients\n   */\n\n\n  exports.generateECPolynomial = function generateECPolynomial(degree) {\n    var poly = typedarrayBuffer.from([1]);\n\n    for (var i = 0; i < degree; i++) {\n      poly = exports.mul(poly, [1, galoisField.exp(i)]);\n    }\n\n    return poly;\n  };\n});\nvar Buffer$1 = buffer.Buffer;\n\nfunction ReedSolomonEncoder(degree) {\n  this.genPoly = undefined;\n  this.degree = degree;\n  if (this.degree) this.initialize(this.degree);\n}\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\n\n\nReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree;\n  this.genPoly = polynomial.generateECPolynomial(this.degree);\n};\n/**\n * Encodes a chunk of data\n *\n * @param  {Buffer} data Buffer containing input data\n * @return {Buffer}      Buffer containing encoded data\n */\n\n\nReedSolomonEncoder.prototype.encode = function encode(data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized');\n  } // Calculate EC for this data block\n  // extends data size to data+genPoly size\n\n\n  var pad = typedarrayBuffer.alloc(this.degree);\n  var paddedData = Buffer$1.concat([data, pad], data.length + this.degree); // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n\n  var remainder = polynomial.mod(paddedData, this.genPoly); // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n\n  var start = this.degree - remainder.length;\n\n  if (start > 0) {\n    var buff = typedarrayBuffer.alloc(this.degree);\n    remainder.copy(buff, start);\n    return buff;\n  }\n\n  return remainder;\n};\n\nvar reedSolomonEncoder = ReedSolomonEncoder;\n/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\n\nvar isValid = function isValid(version) {\n  return !isNaN(version) && version >= 1 && version <= 40;\n};\n\nvar versionCheck = {\n  isValid: isValid\n};\nvar numeric = '[0-9]+';\nvar alphanumeric = '[A-Z $%*+\\\\-./:]+';\nvar kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' + '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' + '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' + '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';\nkanji = kanji.replace(/u/g, \"\\\\u\");\nvar byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+';\nvar KANJI = new RegExp(kanji, 'g');\nvar BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g');\nvar BYTE = new RegExp(byte, 'g');\nvar NUMERIC = new RegExp(numeric, 'g');\nvar ALPHANUMERIC = new RegExp(alphanumeric, 'g');\nvar TEST_KANJI = new RegExp('^' + kanji + '$');\nvar TEST_NUMERIC = new RegExp('^' + numeric + '$');\nvar TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$');\n\nvar testKanji = function testKanji(str) {\n  return TEST_KANJI.test(str);\n};\n\nvar testNumeric = function testNumeric(str) {\n  return TEST_NUMERIC.test(str);\n};\n\nvar testAlphanumeric = function testAlphanumeric(str) {\n  return TEST_ALPHANUMERIC.test(str);\n};\n\nvar regex = {\n  KANJI: KANJI,\n  BYTE_KANJI: BYTE_KANJI,\n  BYTE: BYTE,\n  NUMERIC: NUMERIC,\n  ALPHANUMERIC: ALPHANUMERIC,\n  testKanji: testKanji,\n  testNumeric: testNumeric,\n  testAlphanumeric: testAlphanumeric\n};\nvar mode = createCommonjsModule(function (module, exports) {\n  /**\n   * Numeric mode encodes data from the decimal digit set (0 - 9)\n   * (byte values 30HEX to 39HEX).\n   * Normally, 3 data characters are represented by 10 bits.\n   *\n   * @type {Object}\n   */\n  exports.NUMERIC = {\n    id: 'Numeric',\n    bit: 1 << 0,\n    ccBits: [10, 12, 14]\n  };\n  /**\n   * Alphanumeric mode encodes data from a set of 45 characters,\n   * i.e. 10 numeric digits (0 - 9),\n   *      26 alphabetic characters (A - Z),\n   *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n   * Normally, two input characters are represented by 11 bits.\n   *\n   * @type {Object}\n   */\n\n  exports.ALPHANUMERIC = {\n    id: 'Alphanumeric',\n    bit: 1 << 1,\n    ccBits: [9, 11, 13]\n  };\n  /**\n   * In byte mode, data is encoded at 8 bits per character.\n   *\n   * @type {Object}\n   */\n\n  exports.BYTE = {\n    id: 'Byte',\n    bit: 1 << 2,\n    ccBits: [8, 16, 16]\n  };\n  /**\n   * The Kanji mode efficiently encodes Kanji characters in accordance with\n   * the Shift JIS system based on JIS X 0208.\n   * The Shift JIS values are shifted from the JIS X 0208 values.\n   * JIS X 0208 gives details of the shift coded representation.\n   * Each two-byte character value is compacted to a 13-bit binary codeword.\n   *\n   * @type {Object}\n   */\n\n  exports.KANJI = {\n    id: 'Kanji',\n    bit: 1 << 3,\n    ccBits: [8, 10, 12]\n  };\n  /**\n   * Mixed mode will contain a sequences of data in a combination of any of\n   * the modes described above\n   *\n   * @type {Object}\n   */\n\n  exports.MIXED = {\n    bit: -1\n  };\n  /**\n   * Returns the number of bits needed to store the data length\n   * according to QR Code specifications.\n   *\n   * @param  {Mode}   mode    Data mode\n   * @param  {Number} version QR Code version\n   * @return {Number}         Number of bits\n   */\n\n  exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n    if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);\n\n    if (!versionCheck.isValid(version)) {\n      throw new Error('Invalid version: ' + version);\n    }\n\n    if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];\n    return mode.ccBits[2];\n  };\n  /**\n   * Returns the most efficient mode to store the specified data\n   *\n   * @param  {String} dataStr Input data string\n   * @return {Mode}           Best mode\n   */\n\n\n  exports.getBestModeForData = function getBestModeForData(dataStr) {\n    if (regex.testNumeric(dataStr)) return exports.NUMERIC;else if (regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;\n  };\n  /**\n   * Return mode name as string\n   *\n   * @param {Mode} mode Mode object\n   * @returns {String}  Mode name\n   */\n\n\n  exports.toString = function toString(mode) {\n    if (mode && mode.id) return mode.id;\n    throw new Error('Invalid mode');\n  };\n  /**\n   * Check if input param is a valid mode object\n   *\n   * @param   {Mode}    mode Mode object\n   * @returns {Boolean} True if valid mode, false otherwise\n   */\n\n\n  exports.isValid = function isValid(mode) {\n    return mode && mode.bit && mode.ccBits;\n  };\n  /**\n   * Get mode object from its name\n   *\n   * @param   {String} string Mode name\n   * @returns {Mode}          Mode object\n   */\n\n\n  function fromString(string) {\n    if (typeof string !== 'string') {\n      throw new Error('Param is not a string');\n    }\n\n    var lcStr = string.toLowerCase();\n\n    switch (lcStr) {\n      case 'numeric':\n        return exports.NUMERIC;\n\n      case 'alphanumeric':\n        return exports.ALPHANUMERIC;\n\n      case 'kanji':\n        return exports.KANJI;\n\n      case 'byte':\n        return exports.BYTE;\n\n      default:\n        throw new Error('Unknown mode: ' + string);\n    }\n  }\n  /**\n   * Returns mode from a value.\n   * If value is not a valid mode, returns defaultValue\n   *\n   * @param  {Mode|String} value        Encoding mode\n   * @param  {Mode}        defaultValue Fallback value\n   * @return {Mode}                     Encoding mode\n   */\n\n\n  exports.from = function from(value, defaultValue) {\n    if (exports.isValid(value)) {\n      return value;\n    }\n\n    try {\n      return fromString(value);\n    } catch (e) {\n      return defaultValue;\n    }\n  };\n});\nvar version = createCommonjsModule(function (module, exports) {\n  // Generator polynomial used to encode version information\n  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n  var G18_BCH = utils.getBCHDigit(G18);\n\n  function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {\n    for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n        return currentVersion;\n      }\n    }\n\n    return undefined;\n  }\n\n  function getReservedBitsCount(mode$1, version) {\n    // Character count indicator + mode indicator bits\n    return mode.getCharCountIndicator(mode$1, version) + 4;\n  }\n\n  function getTotalBitsFromDataArray(segments, version) {\n    var totalBits = 0;\n    segments.forEach(function (data) {\n      var reservedBits = getReservedBitsCount(data.mode, version);\n      totalBits += reservedBits + data.getBitsLength();\n    });\n    return totalBits;\n  }\n\n  function getBestVersionForMixedData(segments, errorCorrectionLevel) {\n    for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n      var length = getTotalBitsFromDataArray(segments, currentVersion);\n\n      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode.MIXED)) {\n        return currentVersion;\n      }\n    }\n\n    return undefined;\n  }\n  /**\n   * Returns version number from a value.\n   * If value is not a valid version, returns defaultValue\n   *\n   * @param  {Number|String} value        QR Code version\n   * @param  {Number}        defaultValue Fallback value\n   * @return {Number}                     QR Code version number\n   */\n\n\n  exports.from = function from(value, defaultValue) {\n    if (versionCheck.isValid(value)) {\n      return parseInt(value, 10);\n    }\n\n    return defaultValue;\n  };\n  /**\n   * Returns how much data can be stored with the specified QR code version\n   * and error correction level\n   *\n   * @param  {Number} version              QR Code version (1-40)\n   * @param  {Number} errorCorrectionLevel Error correction level\n   * @param  {Mode}   mode                 Data mode\n   * @return {Number}                      Quantity of storable data\n   */\n\n\n  exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode$1) {\n    if (!versionCheck.isValid(version)) {\n      throw new Error('Invalid QR Code version');\n    } // Use Byte mode as default\n\n\n    if (typeof mode$1 === 'undefined') mode$1 = mode.BYTE; // Total codewords for this QR code version (Data + Error correction)\n\n    var totalCodewords = utils.getSymbolTotalCodewords(version); // Total number of error correction codewords\n\n    var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel); // Total number of data codewords\n\n    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    if (mode$1 === mode.MIXED) return dataTotalCodewordsBits;\n    var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode$1, version); // Return max number of storable codewords\n\n    switch (mode$1) {\n      case mode.NUMERIC:\n        return Math.floor(usableBits / 10 * 3);\n\n      case mode.ALPHANUMERIC:\n        return Math.floor(usableBits / 11 * 2);\n\n      case mode.KANJI:\n        return Math.floor(usableBits / 13);\n\n      case mode.BYTE:\n      default:\n        return Math.floor(usableBits / 8);\n    }\n  };\n  /**\n   * Returns the minimum version needed to contain the amount of data\n   *\n   * @param  {Segment} data                    Segment of data\n   * @param  {Number} [errorCorrectionLevel=H] Error correction level\n   * @param  {Mode} mode                       Data mode\n   * @return {Number}                          QR Code version\n   */\n\n\n  exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel$1) {\n    var seg;\n    var ecl = errorCorrectionLevel.from(errorCorrectionLevel$1, errorCorrectionLevel.M);\n\n    if (isarray(data)) {\n      if (data.length > 1) {\n        return getBestVersionForMixedData(data, ecl);\n      }\n\n      if (data.length === 0) {\n        return 1;\n      }\n\n      seg = data[0];\n    } else {\n      seg = data;\n    }\n\n    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);\n  };\n  /**\n   * Returns version information with relative error correction bits\n   *\n   * The version information is included in QR Code symbols of version 7 or larger.\n   * It consists of an 18-bit sequence containing 6 data bits,\n   * with 12 error correction bits calculated using the (18, 6) Golay code.\n   *\n   * @param  {Number} version QR Code version\n   * @return {Number}         Encoded version info bits\n   */\n\n\n  exports.getEncodedBits = function getEncodedBits(version) {\n    if (!versionCheck.isValid(version) || version < 7) {\n      throw new Error('Invalid QR Code version');\n    }\n\n    var d = version << 12;\n\n    while (utils.getBCHDigit(d) - G18_BCH >= 0) {\n      d ^= G18 << utils.getBCHDigit(d) - G18_BCH;\n    }\n\n    return version << 12 | d;\n  };\n});\nvar G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\nvar G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\nvar G15_BCH = utils.getBCHDigit(G15);\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\n\nvar getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {\n  var data = errorCorrectionLevel.bit << 3 | mask;\n  var d = data << 10;\n\n  while (utils.getBCHDigit(d) - G15_BCH >= 0) {\n    d ^= G15 << utils.getBCHDigit(d) - G15_BCH;\n  } // xor final data with mask pattern in order to ensure that\n  // no combination of Error Correction Level and data mask pattern\n  // will result in an all-zero data string\n\n\n  return (data << 10 | d) ^ G15_MASK;\n};\n\nvar formatInfo = {\n  getEncodedBits: getEncodedBits\n};\n\nfunction NumericData(data) {\n  this.mode = mode.NUMERIC;\n  this.data = data.toString();\n}\n\nNumericData.getBitsLength = function getBitsLength(length) {\n  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);\n};\n\nNumericData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\n\nNumericData.prototype.getBitsLength = function getBitsLength() {\n  return NumericData.getBitsLength(this.data.length);\n};\n\nNumericData.prototype.write = function write(bitBuffer) {\n  var i, group, value; // The input data string is divided into groups of three digits,\n  // and each group is converted to its 10-bit binary equivalent.\n\n  for (i = 0; i + 3 <= this.data.length; i += 3) {\n    group = this.data.substr(i, 3);\n    value = parseInt(group, 10);\n    bitBuffer.put(value, 10);\n  } // If the number of input digits is not an exact multiple of three,\n  // the final one or two digits are converted to 4 or 7 bits respectively.\n\n\n  var remainingNum = this.data.length - i;\n\n  if (remainingNum > 0) {\n    group = this.data.substr(i);\n    value = parseInt(group, 10);\n    bitBuffer.put(value, remainingNum * 3 + 1);\n  }\n};\n\nvar numericData = NumericData;\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\n\nvar ALPHA_NUM_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];\n\nfunction AlphanumericData(data) {\n  this.mode = mode.ALPHANUMERIC;\n  this.data = data;\n}\n\nAlphanumericData.getBitsLength = function getBitsLength(length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2);\n};\n\nAlphanumericData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength() {\n  return AlphanumericData.getBitsLength(this.data.length);\n};\n\nAlphanumericData.prototype.write = function write(bitBuffer) {\n  var i; // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45; // The character value of the second digit is added to the product\n\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]); // The sum is then stored as 11-bit binary number\n\n    bitBuffer.put(value, 11);\n  } // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n\n\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n  }\n};\n\nvar alphanumericData = AlphanumericData;\n\nfunction ByteData(data) {\n  this.mode = mode.BYTE;\n  this.data = typedarrayBuffer.from(data);\n}\n\nByteData.getBitsLength = function getBitsLength(length) {\n  return length * 8;\n};\n\nByteData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\n\nByteData.prototype.getBitsLength = function getBitsLength() {\n  return ByteData.getBitsLength(this.data.length);\n};\n\nByteData.prototype.write = function (bitBuffer) {\n  for (var i = 0, l = this.data.length; i < l; i++) {\n    bitBuffer.put(this.data[i], 8);\n  }\n};\n\nvar byteData = ByteData;\n\nfunction KanjiData(data) {\n  this.mode = mode.KANJI;\n  this.data = data;\n}\n\nKanjiData.getBitsLength = function getBitsLength(length) {\n  return length * 13;\n};\n\nKanjiData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\n\nKanjiData.prototype.getBitsLength = function getBitsLength() {\n  return KanjiData.getBitsLength(this.data.length);\n};\n\nKanjiData.prototype.write = function (bitBuffer) {\n  var i; // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n  // These byte values are shifted from the JIS X 0208 values.\n  // JIS X 0208 gives details of the shift coded representation.\n\n  for (i = 0; i < this.data.length; i++) {\n    var value = utils.toSJIS(this.data[i]); // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n\n    if (value >= 0x8140 && value <= 0x9FFC) {\n      // Subtract 0x8140 from Shift JIS value\n      value -= 0x8140; // For characters with Shift JIS values from 0xE040 to 0xEBBF\n    } else if (value >= 0xE040 && value <= 0xEBBF) {\n      // Subtract 0xC140 from Shift JIS value\n      value -= 0xC140;\n    } else {\n      throw new Error('Invalid SJIS character: ' + this.data[i] + '\\n' + 'Make sure your charset is UTF-8');\n    } // Multiply most significant byte of result by 0xC0\n    // and add least significant byte to product\n\n\n    value = (value >>> 8 & 0xff) * 0xC0 + (value & 0xff); // Convert result to a 13-bit binary string\n\n    bitBuffer.put(value, 13);\n  }\n};\n\nvar kanjiData = KanjiData;\nvar dijkstra_1 = createCommonjsModule(function (module) {\n  /******************************************************************************\n   * Created 2008-08-19.\n   *\n   * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n   *\n   * Copyright (C) 2008\n   *   Wyatt Baldwin <self@wyattbaldwin.com>\n   *   All rights reserved\n   *\n   * Licensed under the MIT license.\n   *\n   *   http://www.opensource.org/licenses/mit-license.php\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   *****************************************************************************/\n  var dijkstra = {\n    single_source_shortest_paths: function single_source_shortest_paths(graph, s, d) {\n      // Predecessor map for each node that has been encountered.\n      // node ID => predecessor node ID\n      var predecessors = {}; // Costs of shortest paths from s to all nodes encountered.\n      // node ID => cost\n\n      var costs = {};\n      costs[s] = 0; // Costs of shortest paths from s to all nodes encountered; differs from\n      // `costs` in that it provides easy access to the node that currently has\n      // the known shortest path from s.\n      // XXX: Do we actually need both `costs` and `open`?\n\n      var open = dijkstra.PriorityQueue.make();\n      open.push(s, 0);\n      var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n\n      while (!open.empty()) {\n        // In the nodes remaining in graph that have a known cost from s,\n        // find the node, u, that currently has the shortest path from s.\n        closest = open.pop();\n        u = closest.value;\n        cost_of_s_to_u = closest.cost; // Get nodes adjacent to u...\n\n        adjacent_nodes = graph[u] || {}; // ...and explore the edges that connect u to those nodes, updating\n        // the cost of the shortest paths to any or all of those nodes as\n        // necessary. v is the node across the current edge from u.\n\n        for (v in adjacent_nodes) {\n          if (adjacent_nodes.hasOwnProperty(v)) {\n            // Get the cost of the edge running from u to v.\n            cost_of_e = adjacent_nodes[v]; // Cost of s to u plus the cost of u to v across e--this is *a*\n            // cost from s to v that may or may not be less than the current\n            // known cost to v.\n\n            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e; // If we haven't visited v yet OR if the current known cost from s to\n            // v is greater than the new cost we just found (cost of s to u plus\n            // cost of u to v across e), update v's cost in the cost list and\n            // update v's predecessor in the predecessor list (it's now u).\n\n            cost_of_s_to_v = costs[v];\n            first_visit = typeof costs[v] === 'undefined';\n\n            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n              costs[v] = cost_of_s_to_u_plus_cost_of_e;\n              open.push(v, cost_of_s_to_u_plus_cost_of_e);\n              predecessors[v] = u;\n            }\n          }\n        }\n      }\n\n      if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n        var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n        throw new Error(msg);\n      }\n\n      return predecessors;\n    },\n    extract_shortest_path_from_predecessor_list: function extract_shortest_path_from_predecessor_list(predecessors, d) {\n      var nodes = [];\n      var u = d;\n\n      while (u) {\n        nodes.push(u);\n        u = predecessors[u];\n      }\n\n      nodes.reverse();\n      return nodes;\n    },\n    find_path: function find_path(graph, s, d) {\n      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n    },\n\n    /**\n     * A very naive priority queue implementation.\n     */\n    PriorityQueue: {\n      make: function make(opts) {\n        var T = dijkstra.PriorityQueue,\n            t = {},\n            key;\n        opts = opts || {};\n\n        for (key in T) {\n          if (T.hasOwnProperty(key)) {\n            t[key] = T[key];\n          }\n        }\n\n        t.queue = [];\n        t.sorter = opts.sorter || T.default_sorter;\n        return t;\n      },\n      default_sorter: function default_sorter(a, b) {\n        return a.cost - b.cost;\n      },\n\n      /**\n       * Add a new item to the queue and ensure the highest priority element\n       * is at the front of the queue.\n       */\n      push: function push(value, cost) {\n        var item = {\n          value: value,\n          cost: cost\n        };\n        this.queue.push(item);\n        this.queue.sort(this.sorter);\n      },\n\n      /**\n       * Return the highest priority element in the queue.\n       */\n      pop: function pop() {\n        return this.queue.shift();\n      },\n      empty: function empty() {\n        return this.queue.length === 0;\n      }\n    }\n  }; // node.js module exports\n\n  {\n    module.exports = dijkstra;\n  }\n});\nvar segments = createCommonjsModule(function (module, exports) {\n  /**\n   * Returns UTF8 byte length\n   *\n   * @param  {String} str Input string\n   * @return {Number}     Number of byte\n   */\n  function getStringByteLength(str) {\n    return unescape(encodeURIComponent(str)).length;\n  }\n  /**\n   * Get a list of segments of the specified mode\n   * from a string\n   *\n   * @param  {Mode}   mode Segment mode\n   * @param  {String} str  String to process\n   * @return {Array}       Array of object with segments data\n   */\n\n\n  function getSegments(regex, mode, str) {\n    var segments = [];\n    var result;\n\n    while ((result = regex.exec(str)) !== null) {\n      segments.push({\n        data: result[0],\n        index: result.index,\n        mode: mode,\n        length: result[0].length\n      });\n    }\n\n    return segments;\n  }\n  /**\n   * Extracts a series of segments with the appropriate\n   * modes from a string\n   *\n   * @param  {String} dataStr Input string\n   * @return {Array}          Array of object with segments data\n   */\n\n\n  function getSegmentsFromString(dataStr) {\n    var numSegs = getSegments(regex.NUMERIC, mode.NUMERIC, dataStr);\n    var alphaNumSegs = getSegments(regex.ALPHANUMERIC, mode.ALPHANUMERIC, dataStr);\n    var byteSegs;\n    var kanjiSegs;\n\n    if (utils.isKanjiModeEnabled()) {\n      byteSegs = getSegments(regex.BYTE, mode.BYTE, dataStr);\n      kanjiSegs = getSegments(regex.KANJI, mode.KANJI, dataStr);\n    } else {\n      byteSegs = getSegments(regex.BYTE_KANJI, mode.BYTE, dataStr);\n      kanjiSegs = [];\n    }\n\n    var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n    return segs.sort(function (s1, s2) {\n      return s1.index - s2.index;\n    }).map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      };\n    });\n  }\n  /**\n   * Returns how many bits are needed to encode a string of\n   * specified length with the specified mode\n   *\n   * @param  {Number} length String length\n   * @param  {Mode} mode     Segment mode\n   * @return {Number}        Bit length\n   */\n\n\n  function getSegmentBitsLength(length, mode$1) {\n    switch (mode$1) {\n      case mode.NUMERIC:\n        return numericData.getBitsLength(length);\n\n      case mode.ALPHANUMERIC:\n        return alphanumericData.getBitsLength(length);\n\n      case mode.KANJI:\n        return kanjiData.getBitsLength(length);\n\n      case mode.BYTE:\n        return byteData.getBitsLength(length);\n    }\n  }\n  /**\n   * Merges adjacent segments which have the same mode\n   *\n   * @param  {Array} segs Array of object with segments data\n   * @return {Array}      Array of object with segments data\n   */\n\n\n  function mergeSegments(segs) {\n    return segs.reduce(function (acc, curr) {\n      var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n\n      if (prevSeg && prevSeg.mode === curr.mode) {\n        acc[acc.length - 1].data += curr.data;\n        return acc;\n      }\n\n      acc.push(curr);\n      return acc;\n    }, []);\n  }\n  /**\n   * Generates a list of all possible nodes combination which\n   * will be used to build a segments graph.\n   *\n   * Nodes are divided by groups. Each group will contain a list of all the modes\n   * in which is possible to encode the given text.\n   *\n   * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n   * The group for '12345' will contain then 3 objects, one for each\n   * possible encoding mode.\n   *\n   * Each node represents a possible segment.\n   *\n   * @param  {Array} segs Array of object with segments data\n   * @return {Array}      Array of object with segments data\n   */\n\n\n  function buildNodes(segs) {\n    var nodes = [];\n\n    for (var i = 0; i < segs.length; i++) {\n      var seg = segs[i];\n\n      switch (seg.mode) {\n        case mode.NUMERIC:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: mode.ALPHANUMERIC,\n            length: seg.length\n          }, {\n            data: seg.data,\n            mode: mode.BYTE,\n            length: seg.length\n          }]);\n          break;\n\n        case mode.ALPHANUMERIC:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: mode.BYTE,\n            length: seg.length\n          }]);\n          break;\n\n        case mode.KANJI:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: mode.BYTE,\n            length: getStringByteLength(seg.data)\n          }]);\n          break;\n\n        case mode.BYTE:\n          nodes.push([{\n            data: seg.data,\n            mode: mode.BYTE,\n            length: getStringByteLength(seg.data)\n          }]);\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * Builds a graph from a list of nodes.\n   * All segments in each node group will be connected with all the segments of\n   * the next group and so on.\n   *\n   * At each connection will be assigned a weight depending on the\n   * segment's byte length.\n   *\n   * @param  {Array} nodes    Array of object with segments data\n   * @param  {Number} version QR Code version\n   * @return {Object}         Graph of all possible segments\n   */\n\n\n  function buildGraph(nodes, version) {\n    var table = {};\n    var graph = {\n      'start': {}\n    };\n    var prevNodeIds = ['start'];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var nodeGroup = nodes[i];\n      var currentNodeIds = [];\n\n      for (var j = 0; j < nodeGroup.length; j++) {\n        var node = nodeGroup[j];\n        var key = '' + i + j;\n        currentNodeIds.push(key);\n        table[key] = {\n          node: node,\n          lastCount: 0\n        };\n        graph[key] = {};\n\n        for (var n = 0; n < prevNodeIds.length; n++) {\n          var prevNodeId = prevNodeIds[n];\n\n          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n            table[prevNodeId].lastCount += node.length;\n          } else {\n            if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;\n            graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + mode.getCharCountIndicator(node.mode, version); // switch cost\n          }\n        }\n      }\n\n      prevNodeIds = currentNodeIds;\n    }\n\n    for (n = 0; n < prevNodeIds.length; n++) {\n      graph[prevNodeIds[n]]['end'] = 0;\n    }\n\n    return {\n      map: graph,\n      table: table\n    };\n  }\n  /**\n   * Builds a segment from a specified data and mode.\n   * If a mode is not specified, the more suitable will be used.\n   *\n   * @param  {String} data             Input data\n   * @param  {Mode | String} modesHint Data mode\n   * @return {Segment}                 Segment\n   */\n\n\n  function buildSingleSegment(data, modesHint) {\n    var mode$1;\n    var bestMode = mode.getBestModeForData(data);\n    mode$1 = mode.from(modesHint, bestMode); // Make sure data can be encoded\n\n    if (mode$1 !== mode.BYTE && mode$1.bit < bestMode.bit) {\n      throw new Error('\"' + data + '\"' + ' cannot be encoded with mode ' + mode.toString(mode$1) + '.\\n Suggested mode is: ' + mode.toString(bestMode));\n    } // Use Mode.BYTE if Kanji support is disabled\n\n\n    if (mode$1 === mode.KANJI && !utils.isKanjiModeEnabled()) {\n      mode$1 = mode.BYTE;\n    }\n\n    switch (mode$1) {\n      case mode.NUMERIC:\n        return new numericData(data);\n\n      case mode.ALPHANUMERIC:\n        return new alphanumericData(data);\n\n      case mode.KANJI:\n        return new kanjiData(data);\n\n      case mode.BYTE:\n        return new byteData(data);\n    }\n  }\n  /**\n   * Builds a list of segments from an array.\n   * Array can contain Strings or Objects with segment's info.\n   *\n   * For each item which is a string, will be generated a segment with the given\n   * string and the more appropriate encoding mode.\n   *\n   * For each item which is an object, will be generated a segment with the given\n   * data and mode.\n   * Objects must contain at least the property \"data\".\n   * If property \"mode\" is not present, the more suitable mode will be used.\n   *\n   * @param  {Array} array Array of objects with segments data\n   * @return {Array}       Array of Segments\n   */\n\n\n  exports.fromArray = function fromArray(array) {\n    return array.reduce(function (acc, seg) {\n      if (typeof seg === 'string') {\n        acc.push(buildSingleSegment(seg, null));\n      } else if (seg.data) {\n        acc.push(buildSingleSegment(seg.data, seg.mode));\n      }\n\n      return acc;\n    }, []);\n  };\n  /**\n   * Builds an optimized sequence of segments from a string,\n   * which will produce the shortest possible bitstream.\n   *\n   * @param  {String} data    Input string\n   * @param  {Number} version QR Code version\n   * @return {Array}          Array of segments\n   */\n\n\n  exports.fromString = function fromString(data, version) {\n    var segs = getSegmentsFromString(data, utils.isKanjiModeEnabled());\n    var nodes = buildNodes(segs);\n    var graph = buildGraph(nodes, version);\n    var path = dijkstra_1.find_path(graph.map, 'start', 'end');\n    var optimizedSegs = [];\n\n    for (var i = 1; i < path.length - 1; i++) {\n      optimizedSegs.push(graph.table[path[i]].node);\n    }\n\n    return exports.fromArray(mergeSegments(optimizedSegs));\n  };\n  /**\n   * Splits a string in various segments with the modes which\n   * best represent their content.\n   * The produced segments are far from being optimized.\n   * The output of this function is only used to estimate a QR Code version\n   * which may contain the data.\n   *\n   * @param  {string} data Input string\n   * @return {Array}       Array of segments\n   */\n\n\n  exports.rawSplit = function rawSplit(data) {\n    return exports.fromArray(getSegmentsFromString(data, utils.isKanjiModeEnabled()));\n  };\n});\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\nfunction setupFinderPattern(matrix, version) {\n  var size = matrix.size;\n  var pos = finderPattern.getPositions(version);\n\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0];\n    var col = pos[i][1];\n\n    for (var r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue;\n\n      for (var c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue;\n\n        if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {\n          matrix.set(row + r, col + c, true, true);\n        } else {\n          matrix.set(row + r, col + c, false, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\n\n\nfunction setupTimingPattern(matrix) {\n  var size = matrix.size;\n\n  for (var r = 8; r < size - 8; r++) {\n    var value = r % 2 === 0;\n    matrix.set(r, 6, value, true);\n    matrix.set(6, r, value, true);\n  }\n}\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\n\nfunction setupAlignmentPattern(matrix, version) {\n  var pos = alignmentPattern.getPositions(version);\n\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0];\n    var col = pos[i][1];\n\n    for (var r = -2; r <= 2; r++) {\n      for (var c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {\n          matrix.set(row + r, col + c, true, true);\n        } else {\n          matrix.set(row + r, col + c, false, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\n\nfunction setupVersionInfo(matrix, version$1) {\n  var size = matrix.size;\n  var bits = version.getEncodedBits(version$1);\n  var row, col, mod;\n\n  for (var i = 0; i < 18; i++) {\n    row = Math.floor(i / 3);\n    col = i % 3 + size - 8 - 3;\n    mod = (bits >> i & 1) === 1;\n    matrix.set(row, col, mod, true);\n    matrix.set(col, row, mod, true);\n  }\n}\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\n\n\nfunction setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n  var size = matrix.size;\n  var bits = formatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n  var i, mod;\n\n  for (i = 0; i < 15; i++) {\n    mod = (bits >> i & 1) === 1; // vertical\n\n    if (i < 6) {\n      matrix.set(i, 8, mod, true);\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true);\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true);\n    } // horizontal\n\n\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true);\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true);\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true);\n    }\n  } // fixed module\n\n\n  matrix.set(size - 8, 8, 1, true);\n}\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix} matrix Modules matrix\n * @param  {Buffer}    data   Data codewords\n */\n\n\nfunction setupData(matrix, data) {\n  var size = matrix.size;\n  var inc = -1;\n  var row = size - 1;\n  var bitIndex = 7;\n  var byteIndex = 0;\n\n  for (var col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--;\n\n    while (true) {\n      for (var c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          var dark = false;\n\n          if (byteIndex < data.length) {\n            dark = (data[byteIndex] >>> bitIndex & 1) === 1;\n          }\n\n          matrix.set(row, col - c, dark);\n          bitIndex--;\n\n          if (bitIndex === -1) {\n            byteIndex++;\n            bitIndex = 7;\n          }\n        }\n      }\n\n      row += inc;\n\n      if (row < 0 || size <= row) {\n        row -= inc;\n        inc = -inc;\n        break;\n      }\n    }\n  }\n}\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Buffer}                        Buffer containing encoded codewords\n */\n\n\nfunction createData(version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  var buffer = new bitBuffer();\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4); // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n\n    buffer.put(data.getLength(), mode.getCharCountIndicator(data.mode, version)); // add binary data sequence to buffer\n\n    data.write(buffer);\n  }); // Calculate required number of bits\n\n  var totalCodewords = utils.getSymbolTotalCodewords(version);\n  var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8; // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4);\n  } // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n\n\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0);\n  } // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n\n\n  var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n\n  for (var i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8);\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel);\n}\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Buffer}                         Buffer containing encoded codewords\n */\n\n\nfunction createCodewords(bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  var totalCodewords = utils.getSymbolTotalCodewords(version); // Total number of error correction codewords\n\n  var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel); // Total number of data codewords\n\n  var dataTotalCodewords = totalCodewords - ecTotalCodewords; // Total number of blocks\n\n  var ecTotalBlocks = errorCorrectionCode.getBlocksCount(version, errorCorrectionLevel); // Calculate how many blocks each group should contain\n\n  var blocksInGroup2 = totalCodewords % ecTotalBlocks;\n  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1; // Number of EC codewords is the same for both groups\n\n  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1; // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n\n  var rs = new reedSolomonEncoder(ecCount);\n  var offset = 0;\n  var dcData = new Array(ecTotalBlocks);\n  var ecData = new Array(ecTotalBlocks);\n  var maxDataSize = 0;\n  var buffer = typedarrayBuffer.from(bitBuffer.buffer); // Divide the buffer into the required number of blocks\n\n  for (var b = 0; b < ecTotalBlocks; b++) {\n    var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2; // extract a block of data from buffer\n\n    dcData[b] = buffer.slice(offset, offset + dataSize); // Calculate EC codewords for this data block\n\n    ecData[b] = rs.encode(dcData[b]);\n    offset += dataSize;\n    maxDataSize = Math.max(maxDataSize, dataSize);\n  } // Create final data\n  // Interleave the data and error correction codewords from each block\n\n\n  var data = typedarrayBuffer.alloc(totalCodewords);\n  var index = 0;\n  var i, r; // Add data codewords\n\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i];\n      }\n    }\n  } // Apped EC codewords\n\n\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i];\n    }\n  }\n\n  return data;\n}\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\n\n\nfunction createSymbol(data, version$1, errorCorrectionLevel, maskPattern$1) {\n  var segments$1;\n\n  if (isarray(data)) {\n    segments$1 = segments.fromArray(data);\n  } else if (typeof data === 'string') {\n    var estimatedVersion = version$1;\n\n    if (!estimatedVersion) {\n      var rawSegments = segments.rawSplit(data); // Estimate best version that can contain raw splitted segments\n\n      estimatedVersion = version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n    } // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n\n\n    segments$1 = segments.fromString(data, estimatedVersion || 40);\n  } else {\n    throw new Error('Invalid data');\n  } // Get the min version that can contain data\n\n\n  var bestVersion = version.getBestVersionForData(segments$1, errorCorrectionLevel); // If no version is found, data cannot be stored\n\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code');\n  } // If not specified, use min version as default\n\n\n  if (!version$1) {\n    version$1 = bestVersion; // Check if the specified version can contain the data\n  } else if (version$1 < bestVersion) {\n    throw new Error('\\n' + 'The chosen QR Code version cannot contain this amount of data.\\n' + 'Minimum version required to store current data is: ' + bestVersion + '.\\n');\n  }\n\n  var dataBits = createData(version$1, errorCorrectionLevel, segments$1); // Allocate matrix buffer\n\n  var moduleCount = utils.getSymbolSize(version$1);\n  var modules = new bitMatrix(moduleCount); // Add function modules\n\n  setupFinderPattern(modules, version$1);\n  setupTimingPattern(modules);\n  setupAlignmentPattern(modules, version$1); // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n\n  setupFormatInfo(modules, errorCorrectionLevel, 0);\n\n  if (version$1 >= 7) {\n    setupVersionInfo(modules, version$1);\n  } // Add data codewords\n\n\n  setupData(modules, dataBits);\n\n  if (isNaN(maskPattern$1)) {\n    // Find best mask pattern\n    maskPattern$1 = maskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n  } // Apply mask pattern\n\n\n  maskPattern.applyMask(maskPattern$1, modules); // Replace format info bits with correct values\n\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern$1);\n  return {\n    modules: modules,\n    version: version$1,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern$1,\n    segments: segments$1\n  };\n}\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\n\n\nvar create = function create(data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text');\n  }\n\n  var errorCorrectionLevel$1 = errorCorrectionLevel.M;\n  var version$1;\n  var mask;\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel$1 = errorCorrectionLevel.from(options.errorCorrectionLevel, errorCorrectionLevel.M);\n    version$1 = version.from(options.version);\n    mask = maskPattern.from(options.maskPattern);\n\n    if (options.toSJISFunc) {\n      utils.setToSJISFunction(options.toSJISFunc);\n    }\n  }\n\n  return createSymbol(data, version$1, errorCorrectionLevel$1, mask);\n};\n\nvar qrcode = {\n  create: create\n};\nvar utils$1 = createCommonjsModule(function (module, exports) {\n  function hex2rgba(hex) {\n    if (typeof hex === 'number') {\n      hex = hex.toString();\n    }\n\n    if (typeof hex !== 'string') {\n      throw new Error('Color should be defined as hex string');\n    }\n\n    var hexCode = hex.slice().replace('#', '').split('');\n\n    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n      throw new Error('Invalid hex color: ' + hex);\n    } // Convert from short to long form (fff -> ffffff)\n\n\n    if (hexCode.length === 3 || hexCode.length === 4) {\n      hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n        return [c, c];\n      }));\n    } // Add default alpha value\n\n\n    if (hexCode.length === 6) hexCode.push('F', 'F');\n    var hexValue = parseInt(hexCode.join(''), 16);\n    return {\n      r: hexValue >> 24 & 255,\n      g: hexValue >> 16 & 255,\n      b: hexValue >> 8 & 255,\n      a: hexValue & 255,\n      hex: '#' + hexCode.slice(0, 6).join('')\n    };\n  }\n\n  exports.getOptions = function getOptions(options) {\n    if (!options) options = {};\n    if (!options.color) options.color = {};\n    var margin = typeof options.margin === 'undefined' || options.margin === null || options.margin < 0 ? 4 : options.margin;\n    var width = options.width && options.width >= 21 ? options.width : undefined;\n    var scale = options.scale || 4;\n    return {\n      width: width,\n      scale: width ? 4 : scale,\n      margin: margin,\n      color: {\n        dark: hex2rgba(options.color.dark || '#000000ff'),\n        light: hex2rgba(options.color.light || '#ffffffff')\n      },\n      type: options.type,\n      rendererOpts: options.rendererOpts || {}\n    };\n  };\n\n  exports.getScale = function getScale(qrSize, opts) {\n    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;\n  };\n\n  exports.getImageWidth = function getImageWidth(qrSize, opts) {\n    var scale = exports.getScale(qrSize, opts);\n    return Math.floor((qrSize + opts.margin * 2) * scale);\n  };\n\n  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {\n    var size = qr.modules.size;\n    var data = qr.modules.data;\n    var scale = exports.getScale(size, opts);\n    var symbolSize = Math.floor((size + opts.margin * 2) * scale);\n    var scaledMargin = opts.margin * scale;\n    var palette = [opts.color.light, opts.color.dark];\n\n    for (var i = 0; i < symbolSize; i++) {\n      for (var j = 0; j < symbolSize; j++) {\n        var posDst = (i * symbolSize + j) * 4;\n        var pxColor = opts.color.light;\n\n        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n          var iSrc = Math.floor((i - scaledMargin) / scale);\n          var jSrc = Math.floor((j - scaledMargin) / scale);\n          pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];\n        }\n\n        imgData[posDst++] = pxColor.r;\n        imgData[posDst++] = pxColor.g;\n        imgData[posDst++] = pxColor.b;\n        imgData[posDst] = pxColor.a;\n      }\n    }\n  };\n});\nvar canvas = createCommonjsModule(function (module, exports) {\n  function clearCanvas(ctx, canvas, size) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    if (!canvas.style) canvas.style = {};\n    canvas.height = size;\n    canvas.width = size;\n    canvas.style.height = size + 'px';\n    canvas.style.width = size + 'px';\n  }\n\n  function getCanvasElement() {\n    try {\n      return document.createElement('canvas');\n    } catch (e) {\n      throw new Error('You need to specify a canvas element');\n    }\n  }\n\n  exports.render = function render(qrData, canvas, options) {\n    var opts = options;\n    var canvasEl = canvas;\n\n    if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n      opts = canvas;\n      canvas = undefined;\n    }\n\n    if (!canvas) {\n      canvasEl = getCanvasElement();\n    }\n\n    opts = utils$1.getOptions(opts);\n    var size = utils$1.getImageWidth(qrData.modules.size, opts);\n    var ctx = canvasEl.getContext('2d');\n    var image = ctx.createImageData(size, size);\n    utils$1.qrToImageData(image.data, qrData, opts);\n    clearCanvas(ctx, canvasEl, size);\n    ctx.putImageData(image, 0, 0);\n    return canvasEl;\n  };\n\n  exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {\n    var opts = options;\n\n    if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n      opts = canvas;\n      canvas = undefined;\n    }\n\n    if (!opts) opts = {};\n    var canvasEl = exports.render(qrData, canvas, opts);\n    var type = opts.type || 'image/png';\n    var rendererOpts = opts.rendererOpts || {};\n    return canvasEl.toDataURL(type, rendererOpts.quality);\n  };\n});\n\nfunction getColorAttrib(color, attrib) {\n  var alpha = color.a / 255;\n  var str = attrib + '=\"' + color.hex + '\"';\n  return alpha < 1 ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"' : str;\n}\n\nfunction svgCmd(cmd, x, y) {\n  var str = cmd + x;\n  if (typeof y !== 'undefined') str += ' ' + y;\n  return str;\n}\n\nfunction qrToPath(data, size, margin) {\n  var path = '';\n  var moveBy = 0;\n  var newRow = false;\n  var lineLength = 0;\n\n  for (var i = 0; i < data.length; i++) {\n    var col = Math.floor(i % size);\n    var row = Math.floor(i / size);\n    if (!col && !newRow) newRow = true;\n\n    if (data[i]) {\n      lineLength++;\n\n      if (!(i > 0 && col > 0 && data[i - 1])) {\n        path += newRow ? svgCmd('M', col + margin, 0.5 + row + margin) : svgCmd('m', moveBy, 0);\n        moveBy = 0;\n        newRow = false;\n      }\n\n      if (!(col + 1 < size && data[i + 1])) {\n        path += svgCmd('h', lineLength);\n        lineLength = 0;\n      }\n    } else {\n      moveBy++;\n    }\n  }\n\n  return path;\n}\n\nvar render = function render(qrData, options, cb) {\n  var opts = utils$1.getOptions(options);\n  var size = qrData.modules.size;\n  var data = qrData.modules.data;\n  var qrcodesize = size + opts.margin * 2;\n  var bg = !opts.color.light.a ? '' : '<path ' + getColorAttrib(opts.color.light, 'fill') + ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>';\n  var path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') + ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>';\n  var viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"';\n  var width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" ';\n  var svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n';\n\n  if (typeof cb === 'function') {\n    cb(null, svgTag);\n  }\n\n  return svgTag;\n};\n\nvar svgTag = {\n  render: render\n};\n\nfunction renderCanvas(renderFunc, canvas, text, opts, cb) {\n  var args = [].slice.call(arguments, 1);\n  var argsNum = args.length;\n  var isLastArgCb = typeof args[argsNum - 1] === 'function';\n\n  if (!isLastArgCb && !canPromise()) {\n    throw new Error('Callback required as last argument');\n  }\n\n  if (isLastArgCb) {\n    if (argsNum < 2) {\n      throw new Error('Too few arguments provided');\n    }\n\n    if (argsNum === 2) {\n      cb = text;\n      text = canvas;\n      canvas = opts = undefined;\n    } else if (argsNum === 3) {\n      if (canvas.getContext && typeof cb === 'undefined') {\n        cb = opts;\n        opts = undefined;\n      } else {\n        cb = opts;\n        opts = text;\n        text = canvas;\n        canvas = undefined;\n      }\n    }\n  } else {\n    if (argsNum < 1) {\n      throw new Error('Too few arguments provided');\n    }\n\n    if (argsNum === 1) {\n      text = canvas;\n      canvas = opts = undefined;\n    } else if (argsNum === 2 && !canvas.getContext) {\n      opts = text;\n      text = canvas;\n      canvas = undefined;\n    }\n\n    return new Promise(function (resolve, reject) {\n      try {\n        var data = qrcode.create(text, opts);\n        resolve(renderFunc(data, canvas, opts));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  try {\n    var data = qrcode.create(text, opts);\n    cb(null, renderFunc(data, canvas, opts));\n  } catch (e) {\n    cb(e);\n  }\n}\n\nvar create$1 = qrcode.create;\nvar toCanvas = renderCanvas.bind(null, canvas.render);\nvar toDataURL = renderCanvas.bind(null, canvas.renderToDataURL); // only svg for now.\n\nvar toString_1 = renderCanvas.bind(null, function (data, _, opts) {\n  return svgTag.render(data, opts);\n});\nvar browser = {\n  create: create$1,\n  toCanvas: toCanvas,\n  toDataURL: toDataURL,\n  toString: toString_1\n};\nvar amplifyTotpSetupCss = \".totp-setup{text-align:center;margin-bottom:30px}.totp-setup img{height:128px;width:128px}\";\nvar logger = new Logger('TOTP');\n\nvar AmplifyTOTPSetup =\n/** @class */\nfunction () {\n  function class_1(hostRef) {\n    registerInstance(this, hostRef);\n    this.inputProps = {\n      autoFocus: true\n    };\n    /** Auth state change handler for this component */\n\n    this.handleAuthStateChange = dispatchAuthStateChangeEvent;\n    /** Used for header text in totp setup component */\n\n    this.headerText = Translations.TOTP_HEADER_TEXT;\n    /** Used for customizing the issuer string in the qr code image */\n\n    this.issuer = Translations.TOTP_ISSUER;\n    this.code = null;\n    this.setupMessage = null;\n    this.qrCodeInput = null;\n    this.loading = false;\n  }\n\n  class_1.prototype.componentWillLoad = function () {\n    this.setup();\n  };\n\n  class_1.prototype.buildOtpAuthPath = function (user, issuer, secretKey) {\n    return \"otpauth://totp/\" + issuer + \":\" + user.username + \"?secret=\" + secretKey + \"&issuer=\" + issuer;\n  };\n\n  class_1.prototype.onTOTPEvent = function (event, data, user) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug('on totp event', event, data);\n            if (!(event === SETUP_TOTP && data === SUCCESS)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , checkContact(user, this.handleAuthStateChange)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.handleTotpInputChange = function (event) {\n    this.setupMessage = null;\n    this.qrCodeInput = event.target.value;\n  };\n\n  class_1.prototype.generateQRCode = function (codeFromTotp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, error_1;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _b.trys.push([0, 2,, 3]);\n\n            _a = this;\n            return [4\n            /*yield*/\n            , browser.toDataURL(codeFromTotp)];\n\n          case 1:\n            _a.qrCodeImageSource = _b.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_1 = _b.sent();\n            dispatchToastHubEvent(error_1);\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.setup = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedIssuer, secretKey, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.setupMessage = null;\n            encodedIssuer = encodeURI(I18n.get(this.issuer));\n\n            if (!Auth || typeof Auth.setupTOTP !== 'function') {\n              throw new Error(NO_AUTH_MODULE_FOUND);\n            }\n\n            this.loading = true;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3, 4, 5]);\n\n            return [4\n            /*yield*/\n            , Auth.setupTOTP(this.user)];\n\n          case 2:\n            secretKey = _a.sent();\n            logger.debug('secret key', secretKey);\n            this.code = this.buildOtpAuthPath(this.user, encodedIssuer, secretKey);\n            this.generateQRCode(this.code);\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            error_2 = _a.sent();\n            dispatchToastHubEvent(error_2);\n            logger.debug(I18n.get(Translations.TOTP_SETUP_FAILURE), error_2);\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            this.loading = false;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.verifyTotpToken = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var user, error_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (event) {\n              event.preventDefault();\n            }\n\n            if (!this.qrCodeInput) {\n              logger.debug('No TOTP Code provided');\n              return [2\n              /*return*/\n              ];\n            }\n\n            user = this.user;\n\n            if (!Auth || typeof Auth.verifyTotpToken !== 'function' || typeof Auth.setPreferredMFA !== 'function') {\n              throw new Error(NO_AUTH_MODULE_FOUND);\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , Auth.verifyTotpToken(user, this.qrCodeInput)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , Auth.setPreferredMFA(user, MfaOption.TOTP)];\n\n          case 3:\n            _a.sent();\n\n            this.setupMessage = I18n.get(Translations.TOTP_SUCCESS_MESSAGE);\n            logger.debug(I18n.get(Translations.TOTP_SUCCESS_MESSAGE));\n            return [4\n            /*yield*/\n            , this.onTOTPEvent(SETUP_TOTP, SUCCESS, user)];\n\n          case 4:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            error_3 = _a.sent();\n            this.setupMessage = I18n.get(Translations.TOTP_SETUP_FAILURE);\n            logger.error(error_3);\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.render = function () {\n    var _this = this;\n\n    return h(Host, null, h(\"amplify-form-section\", {\n      headerText: I18n.get(this.headerText),\n      submitButtonText: I18n.get(Translations.TOTP_SUBMIT_BUTTON_TEXT),\n      handleSubmit: function handleSubmit(event) {\n        return _this.verifyTotpToken(event);\n      },\n      loading: this.loading\n    }, h(\"div\", {\n      class: \"totp-setup\"\n    }, h(\"img\", {\n      src: this.qrCodeImageSource,\n      alt: I18n.get(Translations.QR_CODE_ALT)\n    }), h(\"amplify-form-field\", {\n      label: I18n.get(Translations.TOTP_LABEL),\n      inputProps: this.inputProps,\n      fieldId: \"totpCode\",\n      name: \"totpCode\",\n      handleInputChange: function handleInputChange(event) {\n        return _this.handleTotpInputChange(event);\n      }\n    }))));\n  };\n\n  return class_1;\n}();\n\nAmplifyTOTPSetup.style = amplifyTotpSetupCss;\nexport { AmplifyRadioButton as amplify_radio_button, AmplifyTOTPSetup as amplify_totp_setup };"],"sourceRoot":""}